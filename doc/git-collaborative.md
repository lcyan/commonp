@@Git的协同模式

@介绍集中式和金字塔式两种主要的协同工作模式.

#基于某个项目进行二次开发,需要使用不同的工作模型.原始的项目称为上游项目,
#不能直接在上游项目中提交,可能是因为授权的原因,或者是因为目标用户的需求
#不同.这种基于上游项目进行二次开发.实际上是对各个独立分支进行管理,同时
#又能对上游项目的开发进度兼收并蓄意合并.

@多个版本库组成一个项目,在实际应用中并不罕见,一部分原因可能是版本库需要
 依赖第三方的版本库.这时'子模组协同模式'就可以派上用场了.有的时候还要对
 第三方的版本库进行定制.这时'子树合并'提供了一个解决方案,有的时候,为了
 管理方便(授权或项目确实太庞杂),多个版本库共同组成一个大的项目,例如Google
 Andorid项目就是由进200个版本库组成的.'Andorid式多版本库协同'提供了一个
 非常又去的解决方案,解决了'子模组协同模型'管理上的难题.

@在以后会介绍git-svn工具,可能因为公司对代码严格的授权要求,而不能将公司的
 版本控制服务器从Subversion迁移到Git(实际可以通过对Git版本库细粒度拆分实
 现授权管理)可是这并不能阻止个人使用`git-svn`作为前端工具操作subversion
 版本库.git-svn可以让Git和subversion完美地协同工作.


@@经典Git协同模型

@@集中式协同模型
	可以像集中式版本控制系统那样使用Git,在一个大家都可以访问到的服务器上
	架设Git服务器,所有人都可以从该服务器克隆代码,将本地提交推送到服务器上.

	@回忆一下在使用subversion等集中式版本库控制系统时,对服务器管理上的要求:

	#只允许拥有账号的用户访问版本库.
	#甚至只允许用户访问版本库中的某些路径,其他路径则不能访问.
	#特定目录只允许特定用户执行写操作.
	#服务器可以通过钩子实现特殊功能,如对`commit log`的检查,数据镜像等.
	对于这些需求,Git大部分都能支持,甚至能够做的更多:
	#可以设置谁能访问版本库,谁不能访问版本库.
	#具有更丰富的写操作授权,可以限制那些分支不允许写,那些路径不允许写.
	#可以设置谁能够创建新的分支.
	#可以设置谁能够创建新的版本库.
	#可以设置谁能够强制更新.
	#服务器端同样支持钩子脚本.

	@当然想要完整地实现上述的功能需求,需要使用特殊的服务器软件(如Gitlite)
	来架设Git服务器,这也是通过Git实现传统集中式工作模型的核心.以后会介绍
	如何用Gitolite架设Git服务器,以实现集中式协同模型对版本库授权和管理上的要求.

@@传统式集中式协同模型
	对于简单的代码修改,可以像传统集中式版本库控制系统(Subversion)那样工作,
	参照下图工作流程图.
	@import doc/img/git-collaborative-line-50.jpg

	@但是对于复杂的修改(代码重构/增加复杂功能),这个工作模式就有些不合适了.
	 第一个问题是:很容易将不成熟的代码带入共享的版本库,破坏共享版本库相应
	 分支的代码稳定性.例如破坏编译,破坏每日集成.这是因为开发者克隆版本库后,
	 直接工作在默认的跟踪分支上.当不小心执行`git push`命令时,会将自己的提交
	 推送到服务器上.

	@为了避免上面的问题,开发者可能会延迟推送,在软件开发的整个过程中(例如一个月)
	只在本地提交,而不向服务器推送,这样会产生更严重的问题,数据丢失,开发者可能因为
	操作提交感染病毒,或者不小心删除目录,或者硬盘故障导致工作成功的彻底丢失,这对
	个人和团队来说都是灾难.

	@解决这个问题的方法也简单,就是在本地创建本地分支(功能分支),并且同时在服务器
	 端(共享版本库)也创建自己独享的功能分支.本地提交推送到共享版本库中自己独享的
	 分支上.当开发完成之后,将功能分支合并到主线上,推送到共享版本库,完成开发.当然
	 如果不再需要该特性分支时就要做些清理工作.参考下面的流程图.
	 @import doc/img/git-collaborative-line-67.jpg

@@Gerrit特殊的集中式协同模型

	@传统集中式协同模型的缺点
	传统集中式协同模型的主要问题是在管理上:谁能够向版本库推送?可以信赖某人向版本库推送吗?
	#对于在一个相对固定的团队内容使用集中式协同模式没有问题,因为大家彼此信赖,都熟悉项目的
	#相关领域.但是对于公开项目(开源项目)来说,采用集中式的协同模型,必然只能有部分核心人员
	#具有'写'权限,很多有能力的参与者会被拒之门外,这不利于项目的发展.因此集中式协同模型主要
	#应用在公司范围内和商业软件开发中,而不会成为开源项目的首选.

	@强制代码审核的集中式协同模型
	Andorid项目采用了独特一帜的集中式管理模型--通过Gerrit架设的审核服务器对提交进行强制
	审核.Andorid是由近200个Git版本库组成庞大的项目,为了对庞大的版本库进行管理,Android项目
	开发了两个工具repo和Gerrit进行版本库的管理,其中Gerrit服务器为Android项目引入了特别的
	集中式协同模型.

	@Gerrit服务器通过SSH协议管理Git版本库,并实现了一个web界面的评审工作流.任何注册用户都
	可以参与到项目中来,都可以将Git提交推送到Gerrit管理下的Git版本库(通过Gerrit启动的特殊SSH端口)
	Git推送不能直接推送到分支,而是推送到特殊的引用`refs/for/<branch-name>`,此提交会自动
	转换为形如`refs/changes/<nn>/<review-id>/<patch-set>`的补丁集,此补丁集在Gerrit的Web
	界面中显示为对应的评审任务.评审任务进入审核流程,通过相关负责人的审核后才被接受,并合并
	到正式的版本中.

@@金字塔式协同模式

	@自从分布式版本库控制系统(Mercurial/Hg, Bazaar, Git等)诞生之后,有越来越多的开源项目
	迁移了版本控制系统,例如从Subversion或CVS迁移到分布式版本控制系统.因为众多的开源项目
	逐渐意识到,集中式的版本控制管理方式阻止了更多的人参与项目的开发,对项目的发展不利.

	@集中式版本控制系统的最大问题是,如果没有在服务器端授权,就无法提交,也就无法保存自己
	的更改.开源项目虽然允许所有人访问代码库,但是不可能授权`写操作`给所有的人,否则代码
	质量无法控制(Gerrit审核服务器是例外).与此相对照的是,在使用了分布式版本控制系统之后,
	任何人都可以在本地克隆一个和远程版本库一模一样的版本库,本地的版本库允许任何操作,
	这就极大地调动了开发者投入项目研究的积极性.

	@分布式开发必然带来协同的问题,如何能够让一个素不相识的开发者将他的贡献提交到项目中?
	 如何能够最大化地发动和汇聚全球的智慧?开源社区逐渐发展出金字塔模型(如下图),而这也是
	 必然之选.

	@import doc/img/git-collaborative-line-106.jpg
	金字塔模型的含义是,虽然理论上每个开发者的版本库都是平等的,但是会有一个公认的权威的
	版本库,这个版本库由一个或多个核心开发者负责维护(具有推送权限).核心的开发人员负责
	审核其他贡献者的提交,审核可以通过邮件传递的补丁或访问(pull)贡献者开发的代码库进行.
	由此构成了以核心开发团队为顶层的,所有贡献者共同参与的开发者金字塔.

	@Linux社区就是典型的金字塔结构,Linus Torvalds的版本库是公认的官方版本库,允许核心
	成员的提交.其他贡献者的提交必须经过一个或多个核心成员的审核后,才能经由核心成员代为
	推送到官方版本库.

	@采用这种金字塔式协同模型不需要复杂的Git服务器设置,只需要项目管理者提供一个让其他人
	只读访问的版本库即可.当然管理者要能够通过某种方法向该版本库推送,以便其他人能够通过
	该版本库获得更新.

@@贡献者开放只读版本库

	@因为不能直接向项目只读共享的版本库提交,为了能让项目的管理者获取自己的提交,贡献者
	需要提供项目管理者访问自己版本库的方法.建立一个自己拥有的只读共享版本库是一个简单
	易行的方法.以后会介绍几种快速搭建只读Git版本库的方法,包括用HTTP智能协议搭建Git服务器,
	用Git协议搭建Git服务器.

	@贡献者建立自己的只读共享版本库后,需要检查和整理自己贡献的提交,检查项目如下:

	#贡献的提交要处于一个单独的特性分支中,并且要为该特性分支取一个有意义的名字,使用贡献
	 者的名字及简单的概括性文字是非常好的特性分支名,eg:jiangxin/fix-bug-xxx的分支.
	#贡献的提交是否基于上游对应分支的最新提交?如果不是,需要变基到上游最新提交,以免产生合并.
	 项目的管理者会尽量避免不必要的合并,因此会要求贡献者的提交尽量基于项目的最新提交来进行.
	 使用下面的方式建立跟踪远程分支的本地分支,可以很简单地实现在执行`git pull`操作时使用
	 变基操作取代合并操作.
	$ git checkout -b jiangxin/fix-bug-xxx orgin/master
	$ git config branch.jiangxin/fix-bug-xxx.rebase true
	//do stuff
	$ git pull
	然后贡献者就可以向项目管理者发送通知邮件,告诉项目管理者有新贡献的代码等待他的审核.

	@邮件中大致包含一下内容.

	# 为什么要修改项目的代码.

	# 相应的修改是否经过了测试,或者提交中是否包含了单元测试.

	# 自己版本库的访问地址.

	# 特性分支的名称.

	@Git还提供了一个名为`git request-pull`的命令,可以非常方便地生成上述信息.

@以补丁方式贡献代码

	@使用补丁文件方式贡献代码也是开源项目中常用的协同方式,Git项目本身就是采用该方式运作的.

	#运作方式如下:

	(1)每个用户现在本地版本库修改代码.
	(2)修改完成后,通过执行`git format-patch`命令将提交转换为补丁.
	(3)如果提交很多且比较杂乱,可以考虑使用StGit对提交进行重整.
	(4)调用`git send-email`命令,或者通过图形界面的邮件客户端软件将补丁发给邮件列表及项目维护者.
	(5)项目维护者认可贡献者提交的补丁后,执行`git am`命令应用补丁.
