@@Topgit协同模型

@@作者版本控制系统的三个里程碑

	(1)@Subversion和卖主分支
	从2005年开始我专心于开源软件的研究,定制开发和整合,在这几年的几年,
	一直使用subversion做版本控制,对于定制开发的工作,subversion有一种
	称为卖主分支(vendor Branch)的模式.
	@import doc/img/git-topgit-line-9.jpg

	#由左至右,提交随着时间而递增.
	#主线trunk用于对定制开发的过程进行跟踪.
	#主线的第一个提交v1.0是导入上游(该开源软件的官方版本库)发布的版本.
	#之后在v1.0提交之处建立分支,是为卖主分支(vendor branch).
	#主线上依次进行了c1,c2两次提交,是基于v1.0进行的定制开发.
	#上游有了新版本,提交到卖主分支上,即v2.0提交,和v1.0相比除了大量的文件更改外,
	 还可能有文件增加和删除.
	#然后在主线上执行从卖主分支到主线的合并,即提交M1.因为此时主线上的改动相对
	 较少.合并v2.0并不太费事.
	#主线继续开发.可能同时有针对不同需求的定制开发.在主线上会有越来越多的提交.
	#如果在卖主分支上导入上游的新版本v3.0,合并将非常痛苦,因为主线上针对不同
	 需求的定制开发已经混杂在一起了.

	@实践证明,Subversion的卖主分支对于大规模的定制开发非常不适合.向上游新版本的
	 迁移会随着定制功能和提交的增大变得越来越困难.

	(2)@HG和MQ
	在2008年,我们的版本库迁移到Mercurial(水银,又称为Hg),并工作在'Hg+MQ'模式下,
	我自以为找到了定制开发版本控制系统的终极解决方案,那时我们已被Subversion的
	卖主分支折磨的太久了.
	Hg和Git一样也是一种分布式版本控制系统,MQ是Hg的一个扩展,可以实现提交和补丁
	两种模式之间的切换.Hg版本库上的提交可以通过`hg qimport`命令转化为补丁列表,
	也可以通过`hg qpush, hg qpop`等命令在补丁列表上游移(出栈和入栈).入栈的补丁
	转化为Hg版本库的提交.补丁出栈会从Hg版本库移走最新的提交.

	@相比Subversion的卖主分支,使用`Hg+MQ`的好处在于:
	#针对不同需求的定制开发,其提交被限定在各自独立的补丁文件中而不是混杂在一起.
	#针对同一个需求的定制开发,无论多少次的更改都体现为补丁文件的变化,而补丁文件
	 本身也是被版本控制的.
	#各个补丁之间是顺序依赖关系,形成一个Quilt格式的补丁列表.
	#向上游新版本迁移过程的工作量降低了,除了因为针对各个功能的定制开发被隔离,
	 还有迁移过程也非常具有可操作性.
	#将定制开发迁移至上游新版本的过程是:先将所有补丁出栈,在将上游新版本提交到
	 主线,然后依次将补丁入栈,如果上游新版本的代码改动较大,补丁入栈可能会遇到
	 冲突,在冲突解决完毕后执行`hg gref`命令即可完成定制开发到新的上游版本的迁移.
	 但是如果需要在定制开发上进行多人协作,'Hg+MQ'的弊病就显现了.因为'Hg+MQ'工作
	 模式下,定制开发的成果是一个补丁库,在补丁库上进行协作的难度非常大,当发生
	 冲突的时候,补丁文件本身的冲突会让人眼花缭乱,这就引发了我们第三次版本控制
	 系统大迁移.

	(3)@Git和Topgit
	Topgit是'Topic Git'的简写,使用shell脚本语言开发的辅助工具,对Git功能进行了
	扩展,用于管理特性分支的开发,Topgit为特性分支引入了基准分支的概念,并以此管理
	特性分支间的依赖,让特性分支向上游新版本的迁移变得非常简单.

	@Topgit的主要特点有:

		#上游的原始代码位于开发主线(master分支),而每一个定制开发都对应于一条
		 git特性分支(refs/heads/t/feature_name)

		#特性分支之间的依赖关系不像'Hg+MQ'那样逐一依赖的,而是可以任意设定分支
		 之间的依赖:多重依赖,平行依赖等.

		#特性分支和其他依赖的分支可以导出为Quilt格式的补丁列表.

		#因为针对某一需求的定制开发限定在特定的特性分支中,可以多人协同参与,
		 和正常的Git开发别无二致.

@@Topgit原理

	@下图是一个近似的Topgit实现图(略去了重要的top-base)分支.
	@import doc/img/git-topgit-line-72.jpg
	上图中,主线上的v1.0是上游版本的一次提交.特性分支A和特性分支C都直接依赖
	主线master,而特性分支B则依赖特性分支A.提交M1是特性分支B因为特性分支A更新
	而做的一次迁移.提交M2和M4则分别是特性分支A和C因为上游出现了新版本v2.0而
	做的迁移,当然特性分支B也要做相应的迁移,是为M3.

	上述的图示非常粗糙,因为如果安装这样的设计很难将特性分支导出为补丁文件,
	例如特性分支B导出为补丁,实际上应该是M2和M3之间的差异.而绝不是a2和M3之间
	的差异.Topgit为了能够实现将分支导出为补丁,又为每个特性的开发引入了一个
	特殊的引用(refs/top-bases/*),用于追踪特性分支的'变基',称为特性分支的基准
	分支.所有特性分支的基准分支也形成了复杂的分支关系图.
	@import doc/img/git-topgit-line-83.jpg

	@把图line-72和line-83两张分支图合并,重合点之间的差异就可用于将特性分支
	导出为补丁文件.
	@上面的特性分支B还只是依赖一个分支,如果出现了一个分支依赖多个特性分支的话,
	情况就会更加复杂,也更能体现出这种设计方案的精妙.

	@Topgit还在每个特性分支工作区的根目录引入两个文件,用于记录分支的依赖及关于此分支的说明:

	#文件.topdeps记录该分支所依赖的分支列表.
	 该文件通过`tg create`命令在创建特性分支时自动创建,或者通过`tg depend add`命令来添加新依赖.

	#文件.topmsg记录了该分支的描述信息,该文件通过`tg create`命令在创建特性分支时创建,可以手动编辑.
